[{"title":"android.permission.MODIFY_PHONE_STATE 权限获取","url":"/2021/04/26/android-permission-MODIFY-PHONE-STATE-权限获取/","content":"\n这是一个Android的系统权限，Android是不允许第三方应用获取此权限的，解决方案是把他设成内置应用。\n\n## 如何设为内置应用\n\n需要把apk文件放到 /system/priv-app 目录下；\n1、可以通过 usb 连接到电脑，然后通过adb shell命令，然后 sudo 拿到管理员权限（要root后才行）, 拿到权限后就可以插入文件了\n2、建议建个文件夹然后把apk放在文件夹下 比如 /system/priv-app/xxx/xxx.apk\n3、插入完成后重启下手机应用就会自动安装\n","tags":["Android"]},{"title":"React Native开发的电影下载与播放平台","url":"/2021/04/21/React-Native开发的电影下载与播放平台/","content":"\n## 一个React Native开发的电影下载与播放平台\n\n### 源码 \n\nhttps://github.com/delicious28/mm_movie\n\n### 效果\n\n<div style=\"width:200px;margin-right:20px;display:inline-block\">\n    {% asset_img S10421-17555013.png 200%}\n</div>\n<div style=\"width:200px;margin-right:20px;display:inline-block\">\n    {% asset_img S10421-17560083.png 200%}\n</div>\n\n### 关于电影下载\n\n电影是通过aria2下载到服务器，下载时也是服务器实时获取aria2的进度返回的\n\n### 关于播放\n\n为了方便在电视机顶盒上播放，目前是通过手机自带播放器播放的。\n\n不过 android代码里有接入过饺子视频组件（ https://github.com/Jzvd/JZVideo ），把注释的代码放开即可使用；\n\n"},{"title":"解决使用RN老插件打包报错问题","url":"/2021/04/13/解决使用RN老插件打包报错问题/","content":"\nrn 打包Task :react-native-orientation:verifyReleaseResources FAILED\n\n使用react-native-orientation因为这个插件太老了的原因，apk打包时出错，解决方法如下\n\n在node_modules找到react-native-orientation下android下的build.gradle文件改成新版的型号就好了\n\n原来是这样的\n\n{% asset_img 20200521210351668.png %}\n\n改成这样的\n\n{% asset_img 20200521210318613.png %}\n\n重新打包 ok , 很多几年以前的包都有这个问题，这个方法也适用\n\n转自：https://blog.csdn.net/printf_hello/article/details/106267597\n\n"},{"title":"linux下puppeteer运行报错解决方法","url":"/2021/02/03/linux下puppeteer运行报错解决方法/","content":"\nlinux 或 ubuntu 下运行puppeteer经常会报类似下面的错\n\n`error while loading shared libraries: libnss3.so libXss.so.1 libasound.so.`\n\n原因是缺少对应的库，根据提示安装缺失的库即可\n\nlinux下 apt install libXss\n\n参考 https://blog.csdn.net/zhangpeterx/article/details/104210403\n\nubuntu下 yum install libXss\n"},{"title":"webview打开时有瞬间白屏的问题","url":"/2021/01/23/webview打开时有瞬间白屏的问题/","content":"\n### 遇到的效果是打开webview的时候会有白屏的效果，如下面这样\n\n<div style=\"width:200px;margin:auto\">\n{% asset_img 1611378960352.gif %}\n</div>\n\n### 找了很久的原因，总结下来有这样几点\n\n**1、 loadUrl的时间**\n\n如果打开activity的时候webview已经加载了，但这个时候url由于各种原因还没有获取到，没有执行 webView.loadUrl，如果这样请先隐藏webview，准备好后再显示\n\n**2、加载HTML的时间**\n\n我的做法是webview先隐藏，等到HTML加载完后再显示\n\n``` java\n@Override\npublic void onPageFinished(WebView view, String url) {\n    view.setVisibility(View.VISIBLE);\n    super.onPageFinished(view, url);\n}\n```\n\n---\n\n如果这样打开时还是会有瞬间白屏的闪烁，那可能就要从网页端着手进行优化了\n\n**3、网页打开时在html里直接给body设一个背景色**\n\n因为网页的一些样式和图片是需要下载的，如果是单页面的话还要等JS下载完执行后才进行渲染，这都要时间\n\n所以直接在html返回时就直接在页面里给页面元素定义个背景色\n\n直接在head里给body设了背景图和背景色\n``` html\n<head>\n  ...\n  <style>\n    body{\n      background-image: url('./img/app-local-loading-bg.png');\n      background-repeat: no-repeat;\n      background-color: #5a0037;\n      background-size:cover;\n    }\n  </style>\n</head>\n```","tags":["Android","H5"]},{"title":"android版本与sdk-int对应关系","url":"/2021/01/20/android版本与sdk-int对应关系/","content":"\nAndroid开发中经常会用需要知道Android版本与SDK_INT的对应关系，所以这里总结一下，方便以后查看。\n\n官方链接地址:\n\nhttps://developer.android.com/guide/topics/manifest/uses-sdk-element.html\n\nAndroid版本与Android sdk int的对应关系如下:\n\n| 平台版本              | API 级别    | VERSION_CODE           | 备注                    |\n| ------------------------- | ------------- | ---------------------- | ------------------------- |\n| Android 10.0              | 29            | Q                      | 平台亮点              |\n| Android 9                 | 28            | P                      | 平台亮点              |\n| Android 8.1               | 27            | O_MR1                  | 平台亮点              |\n| Android 8.0               | 26            | O                      | 平台亮点              |\n| Android 7.1.1             | Android 7.1.1 | Android 7.1.1          | Android 7.1.1             |\n| Android 7.1               | 25            | N_MR1                  | 平台亮点              |\n| Android 7.0               | 24            | N                      | 平台亮点              |\n| Android 6.0               | 23            | M                      | 平台亮点              |\n| Android 5.1               | 22            | LOLLIPOP_MR1           | 平台亮点              |\n| Android 5.0               | 21            | LOLLIPOP               | Android 5.0               |\n| Android 4.4W              | 20            | KITKAT_WATCH           | 仅限 KitKat for Wearables |\n| Android 4.4               | 19            | KITKAT                 | 平台亮点              |\n| Android 4.3               | 18            | JELLY_BEAN_MR2         | 平台亮点              |\n| Android 4.2、4.2.2       | 17            | JELLY_BEAN_MR1         | 平台亮点              |\n| Android 4.1、4.1.1       | 16            | JELLY_BEAN             | 平台亮点              |\n| Android 4.0.3、4.0.4     | 15            | ICE_CREAM_SANDWICH_MR1 | 平台亮点              |\n| Android 4.0、4.0.1、4.0.2 | 14            | ICE_CREAM_SANDWICH     | Android 4.0、4.0.1、4.0.2 |\n| Android 3.2               | 13            | HONEYCOMB_MR2          |                           |\n| Android 3.1.x             | 12            | HONEYCOMB_MR1          | 平台亮点              |\n| Android 3.0.x             | 11            | HONEYCOMB              | 平台亮点              |\n| Android 2.3.4             | Android 2.3.4 | Android 2.3.4          | Android 2.3.4             |\n| Android 2.3.3             | 10            | GINGERBREAD_MR1        | 平台亮点              |\n| Android 2.3.2             | Android 2.3.2 | Android 2.3.2          | Android 2.3.2             |\n| Android 2.3.1             | Android 2.3.1 | Android 2.3.1          | Android 2.3.1             |\n| Android 2.3               | 9             | GINGERBREAD            | Android 2.3               |\n| Android 2.2.x             | 8             | FROYO                  | 平台亮点              |\n| Android 2.1.x             | 7             | ECLAIR_MR1             | 平台亮点              |\n| Android 2.0.1             | 6             | ECLAIR_0_1             | Android 2.0.1             |\n| Android 2.0               | 5             | ECLAIR                 | Android 2.0               |\n| Android 1.6               | 4             | DONUT                  | 平台亮点              |\n| Android 1.5               | 3             | CUPCAKE                | 平台亮点              |\n| Android 1.1               | 2             | BASE_1_1               |                           |\n| Android 1.0               | 1             | BASE                   |                           |\n\n \n","tags":["Android"]},{"title":"解决Android下载gradle慢的问题","url":"/2021/01/19/解决Android下载gradle慢的问题/","content":"\n## 使用国内镜像进行替换加速\n\n1. 打开工程文件根目录 build.gradle\n\n2. 在 buildscript 和 allprojects 的 repositories 中分别注释掉 jcenter()，并使用国内镜像进行替换：maven{url 'http://maven.aliyun.com/nexus/content/groups/public/'}\n\n3. 在 buildscript 的 repositories 添加：maven{url \"https://jitpack.io\"}\n\n``` json\nbuildscript {\n    repositories {\n        maven{url 'http://maven.aliyun.com/nexus/content/groups/public/'}\n        maven{url \"https://jitpack.io\"}\n//        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:2.2.0'\n\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n\nallprojects {\n    repositories {\n        maven{url 'http://maven.aliyun.com/nexus/content/groups/public/'}\n//        jcenter()\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n```\n\n最后发现心里感觉会快些。。。\n\n----\n\n实在忍不住可以尝试手动下载gradle\n参考：https://www.jianshu.com/p/558e5955bfbd?from=singlemessage\nps: 最后复制一份gradle-x.x.x-all.zip.lck文件，重命名为gradle-x.x.x-all.zip.ok；\n","tags":["Android"]},{"title":"webview读取android内图片","url":"/2021/01/15/webview读取android内图片/","content":"\n为了进一步优化Android内网页的打开速度，准备将静态图片全都放进app内，不再去请求网络。\n\n曾尝试直接在网页里把图片地址写成 \n\n```\nfile:///android_asset/xxx.png\n```\n\n图片虽然存在，但浏览器会报\n```\nNot allowed to load local resource\n```\n\n为了解决这个问题需要换一个思路，通过拦截webview的request请求，然后返回本地图片来解决\n\n判断如果图片名称包含app-local的，并且app内有这张图片的，便直接返回应用内的图片\n\n```java\n@Override\npublic WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {\n\n    String url = request.getUrl().toString();\n\n    AssetManager assets = mContext.getResources().getAssets();\n\n    if (url.contains(\"app-local\")) {\n        String fileName = \"\";\n        Pattern pat=Pattern.compile(\"[\\\\w-]+[\\\\.][\\\\w-]+[\\\\.](\\\\w)+.$\");//正则判断\n        Matcher mc=pat.matcher(url);//条件匹配\n        while(mc.find()) {\n            fileName= mc.group();//截取文件名后缀名\n            fileName = fileName.replaceAll(\"\\\\.(\\\\w+)\\\\.\",\".\");\n        }\n\n        if(fileName!=\"\"){\n            InputStream input = getClass().getResourceAsStream(\"/assets/cacheImg/\"+fileName);\n            if(input!=null){\n                WebResourceResponse response = new WebResourceResponse(\"image/png\", \"UTF-8\", input);\n                return response;\n            }\n        }\n    }\n\n    return  super.shouldInterceptRequest(view, request);\n}\n```\n","tags":["Android"]},{"title":"Android内Webview上传文件的解决方案","url":"/2021/01/11/Android内Webview上传文件的解决方案/","content":"\n\n网上大部分的都是兼容android3，android4的 可以参考这个 [https://stackoverflow.com/questions/5907369/file-upload-in-webview](https://stackoverflow.com/questions/5907369/file-upload-in-webview)\n\n\n在高版本下以上方法是不生效的，可以参考下列代码\n\n```java\nmWebView.setWebChromeClient(new WebChromeClient() {\n     //For Android API  = 21 (5.0 OS)\n     @Override\n     public boolean onShowFileChooser(WebView webView, ValueCallback<Uri[]> filePathCallback, WebChromeClient.FileChooserParams fileChooserParams) {\n         uploadMessageAboveL = filePathCallback;\n         openImageChooserActivity();\n         return true;\n     }\n    \t...\n });\n```\n\n```java\nprivate void openImageChooserActivity() {\n     Intent intent = new Intent(\n             Intent.ACTION_PICK,\n             android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI);\n     startActivityForResult(intent, FILE_CHOOSER_RESULT_CODE);\n }\n```\n\n```java\n@Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n\t\tif(requestCode == FILE_CHOOSER_RESULT_CODE)\n        {\n            if (null == mUploadMessage && null == uploadMessageAboveL) return;\n            Uri result = data == null || resultCode != RESULT_OK ? null : data.getData();\n            if (uploadMessageAboveL != null) {\n                onActivityResultAboveL(requestCode, resultCode, data);\n            } else if (mUploadMessage != null) {\n                mUploadMessage.onReceiveValue(result);\n                mUploadMessage = null;\n            }\n        }\n        super.onActivityResult(requestCode, resultCode, data);\n    }\n```\n```java\n\t@TargetApi(Build.VERSION_CODES.LOLLIPOP)\n    private void onActivityResultAboveL(int requestCode, int resultCode, Intent intent) {\n        if (requestCode != FILE_CHOOSER_RESULT_CODE || uploadMessageAboveL == null)\n            return;\n        Uri[] results = null;\n        if (resultCode == Activity.RESULT_OK) {\n            if (intent != null) {\n                String dataString = intent.getDataString();\n                ClipData clipData = intent.getClipData();\n                if (clipData != null) {\n                    results = new Uri[clipData.getItemCount()];\n                    for (int i = 0; i < clipData.getItemCount(); i++) {\n                        ClipData.Item item = clipData.getItemAt(i);\n                        results[i] = item.getUri();\n                    }\n                }\n                if (dataString != null)\n                    results = new Uri[]{Uri.parse(dataString)};\n            }\n        }\n        uploadMessageAboveL.onReceiveValue(results);\n        uploadMessageAboveL = null;\n    }\n```\n","tags":["Android"]},{"title":"Android NoClassDefFoundError with java.util.Base64 报错解决","url":"/2021/01/11/报错解决/","content":"\n## java.lang.NoClassDefFoundError: Failed resolution of: Ljava/util/Base64\n在某些低端机上会报这个错\n\n解决方案是使用 Android.util.Base64\n\n``` \nimport android.util.Base64;\n```\n\n","tags":["Android"]},{"title":"如何用快速搭建个人博客","url":"/2021/01/11/如何用快速搭建个人博客/","content":"\n当前这个博客使用的是 hexo 搭建，一个基于nodeJS的开源博客系统，通过本地编译然后上传至我的github。\n\n官网：https://hexo.io/zh-cn/\n\n## 第一步\n\n在本地部署hexo\n\n* npm install hexo-cli -g\n* hexo init blog\n* cd blog\n* npm install\n* hexo server\n\n\n## 第二步\n\ndemo跑起来后，在github下创建一个新仓库，仓库名需按照 xxx.github.io 的规范来创建，创建好后再建一个名为 gh-pages 的分支\n\n创建完后部署参考 https://hexo.io/zh-cn/docs/one-command-deployment\n\n要上传到gh-pages分支下才能在 xxx.github.io 下展示。\n\n\n## vscode 里编写markdown的建议\n\n可以安装一个 Markdown Preview Github Styling 的插件，安装后打开md文件，在右上角有个 Open Prewiew to the sid 的按钮，可以实时预览。\n\n## 一些常用命令\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本\n\n## 一些hexo命令的简写\n\nhexo s --> hexo server\nhexo d -g --> hexo deploy --generate\nhexo g -d --> hexo generate --deploy\n\n## 如何删除文章\n\n删除文章只需要删除source目下对应的md文件即可\n\n\n"}]